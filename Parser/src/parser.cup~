package Parser;

import java_cup.runtime.*;
import java.util.*;
parser code {:
	public static void main(String args[]) throws Exception {
		new parser(new Yylex(System.in)).parse();
	}
:}


terminal FUNCTION, LPAREN, RPAREN, SEMICOLON, VLINE, MAPTO, COLON, DEFINE, CONCAT, APPEND, INT, BOOL, BV, CHAR, WITH, INVERT, MATCH, WHEN;
terminal Integer INTVALUE;
terminal String DECLARATION;
terminal String ID;
terminal String PREDICATE;
terminal TokenVal OUTPUTFUNCTION;

non terminal CoderNode 		coder;
non terminal LinkedList 	decl_list;
non terminal LinkedList 	program_list; 
non terminal ProgNode		program;
non terminal LinkedList		query_list;
non terminal String		query;
non terminal ProgheadNode	program_head;
non terminal ProgbodyNode	program_body;
non terminal InputNode		input;
non terminal TypeNode		type;
non terminal String		match_head;
non terminal LinkedList		case_list;
non terminal CaseNode		case;
non terminal LinkedList		pattern;
non terminal OutputNode		output;
non terminal LinkedList		outputfunction_list;
non terminal FunctionNode	function;

start with coder;

coder			::= decl_list:dl program_list:pl query_list:ql
			{:  RESULT = new CoderNode(new DeclListNode(dl), new ProgListNode(pl), new QueryListNode(ql));
			:};

decl_list		::= decl_list:dl DECLARATION:d 
			{:  dl.addLast(d);
			    RESULT = dl;
			:} 
			| 
			{:  RESULT = new LinkedList<DeclNode>();
			:};

program_list		::= program_list:pl program:p
			{:  pl.addLast(p);
			    RESULT = pl;  
			:} 
			| 
			{:  RESULT = new LinkedList<ProgNode>();
			:};

program			::= program_head:ph DEFINE program_body:pb
			{:  RESULT = new ProgNode(ph,pb);
			:};

program_head		::= FUNCTION ID:idstr input:innode COLON type:t
			{:  RESULT = new ProgheadNode(idstr,innode,t); 
			:};

input 			::= LPAREN ID:idstr COLON type:t RPAREN 
			{:  RESULT = new InputNode(idstr,t); 
			:};

type			::= INT 			{: RESULT = new TypeNode(type.INT); :}
			  | BOOL 			{: RESULT = new TypeNode(type.BOOL); :}
			  | CHAR 			{: RESULT = new TypeNode(type.CHAR); :}
			  | LPAREN BV INTVALUE:n 	{: RESULT = new TypeNode(type.BV,n); :} RPAREN;

program_body		::= match_head:mhstr case_list:cl
			{:  RESULT = new ProgbodyNode(mhstr, new CaseListNode(cl));
			:};

match_head		::= MATCH ID:idstr WITH
			{:  RESULT = idstr;
			:};

case_list		::= case_list:cl VLINE case:c 
			{:  cl.addLast(c);
			    RESULT = cl;
			:}
			| 
			{:  RESULT = new LinkedList<CaseNode>();
			:};

case			::= pattern:p WHEN PREDICATE:predstr MAPTO output:o
			{:  RESULT = new CaseNode(p,predstr,o);
			:};

pattern			::= pattern:p CONCAT ID:idstr 
			{:  p.addLast(idstr); 
			:} 
			| 
			{:  RESULT = new LinkedList<String>(); :};

output			::= outputfunction_list:ofl APPEND function:f
			{:  RESULT = new OutputNode(ofl,f);
			:};

function		::= ID:idstr1 LPAREN ID:idstr2 RPAREN
			{:  RESULT = new FunctionNode(idstr1, idstr2);
			:};

outputfunction_list	::= outputfunction_list:ofl OUTPUTFUNCTION:t  
			{:  ofl.addLast(t);
			    RESULT = ofl; 
			:}
			| 
			{:  RESULT = new LinkedList<TokenVal>();
			:};

query_list		::= query_list:ql query:q
			{:  ql.addLast(q);
			    RESULT = ql;
			:} 
			| 
			{:  RESULT = new LinkedList<String>();
			:};
query			::= INVERT ID:idstr 
			{:  RESULT = idstr;
			:} 
			SEMICOLON;
